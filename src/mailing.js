const fs = require("fs");
const { google } = require("googleapis");
const config = JSON.parse(fs.readFileSync("./config/config.json"));
const { subscribers, host } = config;
const labelModifier = require("./modify");
const attchProvider = require("./attachments");
const messageProvider = require("./message.js");

module.exports.mailMessagesToSubscribers = function mailMessagesToSubscribers(auth) {
  return new Promise(resolve => {
    global.logger.info("Started messaging subscribers...");
    global.logger.info("Searching for unread messages");
    const gmail = google.gmail({ version: "v1", auth });
    messageProvider
      .getUnreadMessages(gmail)
      .then(response => {
        const { data } = response;
        if (data.messages) {
          data.messages.forEach(async msg => {
            const currentMsg = await messageProvider.getMessageData(gmail, msg);
            const isProvider = await messageProvider.isProvider(gmail, msg);
            global.logger.info(`Is author a msg provider ? ${isProvider ? "Yes" : "No"}`);
            if (currentMsg.data && isProvider) {
              global.logger.info("Starting messaging subscribers...");
              if (!process.env.DEBUG_LOGGER) {
                subscribers.forEach(async sub => {
                  const { data } = currentMsg;
                  const copiedMsg = await copyMessage(gmail, data, sub, host);
                  messageProvider.sendMessage(gmail, sub, copiedMsg.join("\n"), data, host);
                });
              } else {
                const { data } = currentMsg;
                const user = { firstName: "Иван", lastName: "Садыков", email: "grandpajok@gmail.com" };
                const copiedMsg = await copyMessage(gmail, data, user, host);
                messageProvider.sendMessage(gmail, user, copiedMsg.join("\n"), data, host);
                labelModifier.removeLabels(gmail, data, ["UNREAD"]);
              }
            } else {
              labelModifier.removeLabels(gmail, currentMsg.data, ["UNREAD"]);
            }
          });
        } else {
          global.logger.info("There was no new messages");
        }
      })
      .then(() => {
        resolve();
      });
  }).then(() => {
    const message = "Done messaging subscribers";
    return message;
  });
};

function copyMessage(gmail, data, user, host) {
  return new Promise(resolve => {
    const metadataHeaders = data.payload.headers;
    metadataHeaders[metadataHeaders.findIndex(header => header.name === "To")] = {
      name: "To",
      value: `${user.firstName} ${user.lastName} <${user.email}>`
    };

    metadataHeaders[metadataHeaders.findIndex(header => header.name === "From")] = {
      name: "From",
      value: `<${host.email}>`
    };

    const headers = [];
    const to = metadataHeaders.find(header => header.name === "To");
    const from = metadataHeaders.find(header => header.name === "From");
    const mime = metadataHeaders.find(header => header.name === "MIME-Version");
    const messageId = metadataHeaders.find(header => header.name === "Message-ID");
    const subject = metadataHeaders.find(header => header.name === "Subject");
    const contentType = metadataHeaders.find(header => header.name === "Content-Type");
    const references = metadataHeaders.find(header => header.name === "References");
    headers.push(`${to.name}: ${to.value}`);
    headers.push(`${from.name}: ${from.value}`);
    headers.push(`${mime.name}: ${mime.value}`);
    headers.push(`${messageId.name}: ${messageId.value}`);
    headers.push(`${subject.name}: ${subject.value}`);
    if (references) {
      headers.push(`${references.name}: ${references.value}`);
    }
    headers.push(`${contentType.name}: ${contentType.value}`);

    const messageParts = headers;

    const boundary = data.payload.headers
      .find(header => header.name === "Content-Type")
      .value.split(";")[1]
      .trim()
      .split("boundary=")[1]
      .replace(/["]/g, "");
    let messages = [];
    messageParts.push(`--${boundary}`);
    messageParts.push(`"Content-Type: text/plain; charset="UTF-8""`);
    messageParts.push(`Content-Transfer-Encoding: base64`);
    messageParts.push("This is autogenerated message. Do not respond!");
    messageParts.push("");
    messageParts.push(`--${boundary}`);
    for (const attachment of data.payload.parts) {
      const mimes = attachment.headers;
      if (!attachment.mimeType.includes("text")) {
        let once = 0;
        mimes.forEach(mime => {
          if (attachment.mimeType.includes("multipart")) {
            messageParts.push(`${mime.name}: ${mime.value}`);
            getSchema(gmail, messageParts, attachment, data.id);
          } else {
            if (once === 0 && attachment.body.attachmentId) {
              messageParts.push(`--${boundary}`);
              once++;
            }
            messageParts.push(`${mime.name}: ${mime.value}`);
          }
        });
        if (attachment.body.attachmentId) {
          attchProvider.appendMediaAttachment(gmail, messageParts, attachment, data.id);
        }
      } else {
        messages.push(attachment);
      }
    }
    setTimeout(() => {
      resolve({
        messages,
        messageParts,
        boundary
      });
    }, 3000);
  })
    .then(resolved => {
      resolved.messages.forEach(message => {
        resolved.messageParts.push("");
        resolved.messageParts.push(`--${resolved.boundary}`);
        attchProvider.appendTextAttachment(resolved.messageParts, message);
      });
      resolved.messageParts.push("");
      resolved.messageParts.push(`--${resolved.boundary}--`);
      return resolved.messageParts;
    })
    .then(messageParts => {
      return messageParts;
    });
}

function getSchema(gmail, messageParts, attachments, messageId) {
  const mimes = attachments.headers;
  const boundary = attachments.headers
    .find(header => header.name === "Content-Type")
    .value.split(";")[1]
    .trim()
    .split("boundary=")[1]
    .replace(/["]/g, "");
  let messages = [];
  attachments.parts.forEach(attachment => {
    if (!attachment.mimeType.includes("text")) {
      let once = 0;
      mimes.forEach(mime => {
        if (attachment.mimeType.includes("multipart")) {
          messageParts.push(`${mime.name}: ${mime.value}`);
          getSchema(gmail, messageParts, attachment, messageId);
        } else {
          if (once === 0 && attachment.body.attachmentId) {
            messageParts.push(`--${boundary}`);
            once++;
          }
          messageParts.push(`${mime.name}: ${mime.value}`);
        }
      });
      if (attachment.body.attachmentId) {
        attchProvider.appendMediaAttachment(gmail, messageParts, attachment, messageId);
      }
    } else {
      messages.push(attachment);
    }
  });
  messages.forEach(message => {
    messageParts.push("");
    messageParts.push(`--${boundary}`);
    attchProvider.appendTextAttachment(messageParts, message);
  });
  messageParts.push("");
  messageParts.push(`--${boundary}--`);
  messageParts.push("");
}

module.exports.getSchema = getSchema;
